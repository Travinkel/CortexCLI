"""
LLM-Based Flashcard Generator

Uses structured prompts with Gemini to generate grammatically correct,
atomic flashcards from source content.

Key principle: Generate correct by construction, not filter after the fact.

Quality pipeline:
1. LLM generates cards with strict grammar instructions
2. Perplexity filter (GPT-2) rejects incoherent text
3. POS grammar validation (spaCy) catches structural issues
"""
from __future__ import annotations

import json
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Optional

import google.generativeai as genai
from loguru import logger

from config import get_settings


@dataclass
class GeneratedCard:
    """A flashcard generated by the LLM."""
    question: str
    answer: str
    card_type: str  # flashcard, cloze
    section_id: str  # CCNA section ID
    module_number: int
    source_text: str  # Original text used for generation
    quality_score: float = 1.0
    perplexity: Optional[float] = None


FLASHCARD_SYSTEM_PROMPT = """You are an expert flashcard creator for Cisco CCNA certification content.

Your task: Generate atomic, grammatically perfect flashcards from the given content.

RULES (strict):
1. Each flashcard tests ONE atomic fact only
2. Questions must be complete, grammatical English sentences ending in ?
3. Answers should be 5-25 words - enough context to understand, not more
4. Never create vague questions like "What is this?" or "What does X refer to?"
5. Never start answers with articles (a, an, the) unless grammatically required
6. For acronyms: "What does X stand for?" → "Full Name Here"
7. For definitions: "What is [specific term]?" → "Clear definition with context"
8. For facts: "What [specific aspect] of [topic]?" → "The specific fact"

BAD examples (never generate these):
- "What is This?" ❌
- "In networking, what concept The concept?" ❌
- "What circuits The circuits?" ❌
- Questions with incomplete grammar ❌

GOOD examples:
- "What does BYOD stand for?" → "Bring Your Own Device"
- "What is the maximum transmission speed of Cat6 cable?" → "10 Gbps up to 55 meters"
- "What layer of the OSI model handles routing?" → "Layer 3, the Network layer"

OUTPUT FORMAT:
Return a JSON array of flashcard objects:
[
  {"question": "...", "answer": "...", "type": "flashcard"},
  {"question": "...", "answer": "...", "type": "cloze"}
]

For cloze cards, use {{c1::answer}} syntax in the question field.
"""


class LLMFlashcardGenerator:
    """
    Generate flashcards using LLM with structured prompts.

    Quality pipeline:
    1. LLM generation with strict grammar instructions
    2. Perplexity filtering (optional, requires transformers)
    3. POS grammar validation (optional, requires spaCy)
    """

    def __init__(self, use_quality_validation: bool = True):
        """
        Initialize the generator.

        Args:
            use_quality_validation: Enable perplexity + grammar validation
        """
        settings = get_settings()

        if not settings.gemini_api_key:
            raise ValueError("GEMINI_API_KEY not configured in .env")

        genai.configure(api_key=settings.gemini_api_key)
        self.model = genai.GenerativeModel(
            model_name=settings.ai_model,
            generation_config={
                "temperature": 0.3,  # Low for consistency
                "top_p": 0.8,
                "max_output_tokens": 4096,
            },
            system_instruction=FLASHCARD_SYSTEM_PROMPT,
        )
        self.settings = settings

        # Initialize quality validator
        self.validator = None
        if use_quality_validation:
            try:
                from src.generation.quality_validator import QualityValidator
                self.validator = QualityValidator()
                logger.info("Quality validation enabled (perplexity + grammar)")
            except Exception as e:
                logger.warning(f"Quality validation not available: {e}")

    def generate_from_section(
        self,
        section_title: str,
        section_content: str,
        section_id: Optional[str] = None,
        module_number: Optional[int] = None,
        max_cards: int = 10,
    ) -> list[GeneratedCard]:
        """
        Generate flashcards from a section of content.

        Args:
            section_title: Title of the section (can include section_id like "1.2.1 Host Roles")
            section_content: The raw text content
            section_id: CCNA section ID (e.g., "1.1.3") - auto-extracted from title if not provided
            module_number: Module number (1-16) - auto-extracted from section_id if not provided
            max_cards: Maximum number of cards to generate

        Returns:
            List of GeneratedCard objects (validated)
        """
        # Auto-extract section_id from title if not provided (e.g., "1.2.1 Host Roles" -> "1.2.1")
        if section_id is None:
            id_match = re.match(r'^(\d+\.\d+(?:\.\d+)?)\s+', section_title)
            section_id = id_match.group(1) if id_match else "0.0"

        # Auto-extract module_number from section_id (e.g., "1.2.1" -> 1)
        if module_number is None:
            module_match = re.match(r'^(\d+)', section_id)
            module_number = int(module_match.group(1)) if module_match else 0

        # Truncate content if too long (Gemini context limit)
        if len(section_content) > 8000:
            section_content = section_content[:8000] + "..."

        prompt = f"""Generate {max_cards} flashcards from this CCNA networking content.

SECTION: {section_id} - {section_title}

CONTENT:
{section_content}

Remember:
- Only complete, grammatical English questions
- One atomic fact per card
- 5-25 words for answers (include brief context)
- Mix of flashcard and cloze types (60% flashcard, 40% cloze)
- For cloze: use {{{{c1::answer}}}} syntax

Return JSON array only, no markdown code blocks."""

        try:
            response = self.model.generate_content(prompt)
            cards = self._parse_response(
                response.text,
                section_id,
                module_number,
                section_content,
            )

            # Apply quality validation
            if self.validator:
                cards = self._validate_cards(cards)

            return cards

        except Exception as e:
            logger.error(f"LLM generation failed for '{section_id}': {e}")
            return []

    def _parse_response(
        self,
        response_text: str,
        section_id: str,
        module_number: int,
        source_text: str,
    ) -> list[GeneratedCard]:
        """Parse LLM response into GeneratedCard objects."""
        cards = []

        # Extract JSON from response (may have markdown formatting)
        json_match = re.search(r'\[[\s\S]*\]', response_text)
        if not json_match:
            logger.warning("No JSON array found in LLM response")
            return []

        try:
            raw_cards = json.loads(json_match.group())
        except json.JSONDecodeError as e:
            logger.warning(f"Failed to parse LLM JSON: {e}")
            return []

        for raw in raw_cards:
            if not isinstance(raw, dict):
                continue

            question = raw.get("question", "").strip()
            answer = raw.get("answer", "").strip()
            card_type = raw.get("type", "flashcard").strip()

            # Basic validation
            if not question or not answer:
                continue
            if len(question) < 15 or len(answer) < 3:
                continue
            if not question.endswith("?") and "{{c1::" not in question:
                continue

            cards.append(GeneratedCard(
                question=question,
                answer=answer,
                card_type=card_type if card_type in ("flashcard", "cloze") else "flashcard",
                section_id=section_id,
                module_number=module_number,
                source_text=source_text[:500],
            ))

        return cards

    def _validate_cards(self, cards: list[GeneratedCard]) -> list[GeneratedCard]:
        """Apply perplexity + grammar validation to cards."""
        validated = []

        for card in cards:
            result = self.validator.validate(card.question, card.answer)

            if result.is_valid:
                card.perplexity = result.perplexity
                validated.append(card)
            else:
                logger.debug(f"Rejected by validation: {card.question[:50]}... ({result.reason})")

        logger.info(f"Validation: {len(validated)}/{len(cards)} passed")
        return validated


def extract_sections_from_txt(module_path: Path) -> list[dict]:
    """
    Extract sections from a CCNA module TXT file.

    Returns list of dicts with: section_id, title, content, module_number
    """
    content = module_path.read_text(encoding='utf-8')

    # Extract module number from filename
    module_match = re.search(r'Module\s*(\d+)', module_path.stem)
    module_number = int(module_match.group(1)) if module_match else 0

    sections = []

    # Find all section headers (X.Y.Z Title format)
    # Patterns: ## 1.1.1 Title, # **1.1.1 Title**, 1.1.1 Title
    section_pattern = r'^(?:#{1,4}\s*(?:\*\*)?)?(\d+\.\d+(?:\.\d+)?)\s+(.+?)(?:\*\*)?$'

    matches = list(re.finditer(section_pattern, content, re.MULTILINE))

    for i, match in enumerate(matches):
        section_id = match.group(1)
        title = match.group(2).strip().rstrip('*')
        start_pos = match.end()

        # Find end of section (next section or end of file)
        if i + 1 < len(matches):
            end_pos = matches[i + 1].start()
        else:
            end_pos = len(content)

        section_content = content[start_pos:end_pos].strip()

        # Skip very short sections
        if len(section_content) < 100:
            continue

        # Limit to ~3000 words
        words = section_content.split()
        if len(words) > 3000:
            section_content = ' '.join(words[:3000])

        sections.append({
            "section_id": section_id,
            "title": title,
            "content": section_content,
            "module_number": module_number,
        })

    return sections


def generate_from_txt_files(
    modules_dir: Path,
    module_numbers: list[int] = None,
    max_per_section: int = 8,
    use_validation: bool = True,
) -> list[GeneratedCard]:
    """
    Generate flashcards from CCNA TXT files.

    Args:
        modules_dir: Directory containing CCNA Module X.txt files
        module_numbers: List of module numbers to process (None = all)
        max_per_section: Max cards per section
        use_validation: Enable perplexity + grammar validation

    Returns:
        List of all generated cards
    """
    generator = LLMFlashcardGenerator(use_quality_validation=use_validation)
    all_cards = []

    # Find module files
    if module_numbers:
        txt_files = [modules_dir / f"CCNA Module {n}.txt" for n in module_numbers]
        txt_files = [f for f in txt_files if f.exists()]
    else:
        txt_files = sorted(modules_dir.glob("CCNA Module *.txt"))

    logger.info(f"Found {len(txt_files)} module files to process")

    for txt_file in txt_files:
        logger.info(f"Processing: {txt_file.name}")

        sections = extract_sections_from_txt(txt_file)
        logger.info(f"  Found {len(sections)} sections")

        for section in sections:
            logger.info(f"  Generating for {section['section_id']}: {section['title'][:40]}")

            cards = generator.generate_from_section(
                section_id=section["section_id"],
                section_title=section["title"],
                section_content=section["content"],
                module_number=section["module_number"],
                max_cards=max_per_section,
            )

            logger.info(f"    Generated {len(cards)} valid cards")
            all_cards.extend(cards)

    return all_cards


def generate_cards_for_module(
    module_number: int,
    modules_dir: Optional[Path] = None,
    max_per_section: int = 8,
    use_validation: bool = True,
) -> list[GeneratedCard]:
    """
    Generate flashcards for a specific CCNA module.

    Convenience wrapper around generate_from_txt_files for single module.

    Args:
        module_number: Module number (1-17)
        modules_dir: Directory containing CCNA TXT files (auto-detected if None)
        max_per_section: Max cards per section
        use_validation: Enable perplexity + grammar validation

    Returns:
        List of generated cards for the module
    """
    if modules_dir is None:
        modules_dir = Path(__file__).parent.parent.parent / "docs" / "CCNA"

    return generate_from_txt_files(
        modules_dir,
        module_numbers=[module_number],
        max_per_section=max_per_section,
        use_validation=use_validation,
    )


if __name__ == "__main__":
    # Test generation from TXT files
    import sys

    modules_dir = Path(__file__).parent.parent.parent / "docs" / "CCNA"

    # Test with module 1
    module = int(sys.argv[1]) if len(sys.argv) > 1 else 1
    cards = generate_cards_for_module(
        module_number=module,
        modules_dir=modules_dir,
        max_per_section=5,
        use_validation=True,
    )

    print(f"\n=== Generated {len(cards)} cards for Module {module} ===\n")
    for i, card in enumerate(cards[:10], 1):
        print(f"{i}. [{card.card_type}] ({card.section_id})")
        print(f"   Q: {card.question}")
        print(f"   A: {card.answer}")
        if card.perplexity:
            print(f"   Perplexity: {card.perplexity:.1f}")
        print()
